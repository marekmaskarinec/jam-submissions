
import (
	"entity.um"
	"global.um"
	"input.um"
	"polygon.um"
	"rawdraw.um"
	"tophat.um"
	"raycast.um"
	"vec.um"
)

type Player = struct {
	ent: entity.ent
	controls: str
}

type Obstacle = interface {
	draw()
	get_ent(): ^entity.ent
	handle()
}

type Saw = struct {
	ent: entity.ent
	speed: real
	bound_min, bound_max: real
	dir: int
}

type Log = struct {
	ent: entity.ent
	speed: real
	bound_min, bound_max: real
	dir: int
}

const (
	wire_thickness = 2
)

var (
	p1, p2: Player
	w_ray: raycast.ray
	move_speed: real
	test_saw: Saw
	test_log: Log
)

// player
fn (p: ^Player) handle() {
	if input.ispressed(int32(p.controls[0])) {
		p.ent.p.y -= move_speed * tophat.delta
	}

	if input.ispressed(int32(p.controls[2])) {
		p.ent.p.y += move_speed * tophat.delta
	}

	if input.ispressed(int32(p.controls[1])) {
		p.ent.p.x -= move_speed * tophat.delta
	}

	if input.ispressed(int32(p.controls[3])) {
		p.ent.p.x += move_speed * tophat.delta
	}
}

// obstacles
fn (s: ^Saw) handle() {
	if s.ent.p.x <= s.bound_min {
		s.dir = 1
		s.ent.p.x = s.bound_min + 1
	}

	if s.ent.p.x >= s.bound_max {
		s.dir = -1
		s.ent.p.x = s.bound_max - 1
	}

	s.ent.p.x += s.speed * s.dir * tophat.delta
}

fn (s: ^Saw) draw() {
	s.ent.draw(global.cam)
}

fn (s: ^Saw) get_ent(): ^entity.ent {
	return &s.ent
}

fn mk_saw(x, y, speed, min, max: real): Saw {
	s := Saw{}
	s.ent = entity.mk(polygon.mk(x, y, []int32{0, 0, 10, 0, 10, 10, 0, 10}), tophat.red, 0)
	s.speed = speed
	s.bound_min = min
	s.bound_max = max
	if s.ent.p.x <= s.bound_min || s.ent.p.x >= s.bound_max {
		s.ent.p.x = min + 1
	}
	s.dir = 1

	return s
}

fn (s: ^Log) handle() {
	s.ent.p.y += s.speed * s.dir * tophat.delta
}

fn (s: ^Log) draw() {
	s.ent.draw(global.cam)
}

fn (s: ^Log) get_ent(): ^entity.ent {
	return &s.ent
}

fn mk_log(x, y, speed: real, dir: int): Log {
	s := Log{}
	s.ent = entity.mk(polygon.mk(x, y, []int32{0, 0, 20, 0, 20, 5, 0, 5}), tophat.red, 0)
	s.speed = speed
	s.dir = dir

	return s
}

fn init*() {
	p1 = Player{entity.mk(polygon.mk(0, 0, []int32{0, 0, 10, 0, 10, 10, 0, 10}), tophat.black, -2), "wasd"}
	p2 = Player{entity.mk(polygon.mk(20, 20, []int32{0, 0, 10, 0, 10, 10, 0, 10}), tophat.black, -3), "khjl"}
	move_speed = 0.2

	w_ray = raycast.ray{}

	test_saw = mk_saw(-10, -10, 0.05, -40, 20)
	test_log = mk_log(0, 100, 0.06, -1)
}

// main loop
fn run*() {
	p1.handle()
	p2.handle()
	test_saw.handle()
	test_log.handle()

	w_ray.x = p1.ent.p.x + p1.ent.p.w/2
	w_ray.y = p1.ent.p.y + p1.ent.p.h/2
	w_ray.l = round(vec.distanceto(p1.ent.p.x + p1.ent.p.w/2, p1.ent.p.y + p1.ent.p.h/2, p2.ent.p.x + p2.ent.p.w/2, p2.ent.p.y + p2.ent.p.h/2))
	w_ray.r = round(vec.angleto(p1.ent.p.x + p1.ent.p.w/2, p1.ent.p.y + p1.ent.p.h/2, p2.ent.p.x + p2.ent.p.w/2, p2.ent.p.y + p2.ent.p.h/2)) - 90
	
	//wire = entity.mk(polygon.mk(p1.ent.p.x, p1.ent.p.y, []int32{0, 0, round(p2.ent.p.x + p2.ent.p.w/2), round(p2.ent.p.y + p2.ent.p.h/2), round(p2.ent.p.x + p2.ent.p.w/2 + wire_thickness), round(p2.ent.p.y + p2.ent.p.h/2 + wire_thickness), wire_thickness, wire_thickness}), tophat.black, -1)

	//wire.draw(global.cam)
	camx := global.cam.x - global.cam.w/2
	camy := global.cam.y - global.cam.h/2
	rawdraw.drawline(round(p1.ent.p.x + p1.ent.p.w/2 - camx), round(p1.ent.p.y + p1.ent.p.h/2 - camy), round(p2.ent.p.x + p2.ent.p.w/2 - camx), round(p2.ent.p.y + p2.ent.p.h/2 - camy), 2, tophat.black)

	scn := []^entity.ent{test_saw.get_ent()}

	test_saw.ent.color = tophat.red
	if bool(p1.ent.getcoll(scn)) || bool(p2.ent.getcoll(scn)) || bool(w_ray.getcoll(scn)) {
		test_saw.ent.color = tophat.cyan
	}	

	p1.ent.draw(global.cam)
	p2.ent.draw(global.cam)
	test_saw.draw()
	test_log.draw()

	/*ex, ey := vec.rotatepoint(w_ray.x, w_ray.y-w_ray.l, w_ray.x, w_ray.y, w_ray.r)
	rawdraw.drawline(round(w_ray.x-camx), round(w_ray.y-camy), round(ex-camx), round(ey-camy), 4, tophat.red)*/
}
