
import (
	"entity.um"
	"polygon.um"
	"input.um"
	"tophat.um"
	"misc.um"

	"level.um"
	"global.um"
)

var (
	ent: entity.ent
	mx, my: real
	maxy: real = 0.2
	gscale: real = 0.001
	canjump: bool = false
)

fn init*() {
	ent = entity.mk(polygon.mk(60, 30, []int32{0, 0, 5, 0, 5, 10, 0, 10}), tophat.cyan, -1)
}

fn handle*() {
	//ent.p.x, ent.p.y = input.getglobalmousepos(global.cam)
	var cx, cy, tx, ty: int32
	ent.color = tophat.cyan * int(level.tmap.getcoll(ent, &cx, &cy, &tx, &ty)) | 0xff

	moved := false
	if input.ispressed(input.KEY_A) {
		moved = true
		ent.p.x -= 0.04 * tophat.delta
	}
	if input.ispressed(input.KEY_D) {
		moved = true
		ent.p.x += 0.04 * tophat.delta
	}

	if moved {
		coll := level.tmap.getcoll(ent, &cx, &cy, &tx, &ty)
		ctx := round((ent.p.x - level.tmap.x) / level.tmap.cellsize)
		cty := round((ent.p.y - level.tmap.y) / level.tmap.cellsize)
		fty := round((ent.p.y + ent.p.h - level.tmap.y - 1) / level.tmap.cellsize)
		if coll && (cy == round(ent.p.y) || ty == cty || cty + 1 != fty) {
			canjump = true
			right := false
			if cx != round(ent.p.x) {
				right = true
			}

			ent.p.x = (cx/level.tmap.cellsize + 1) * level.tmap.cellsize

			if right {
				ent.p.x -= (ent.p.w + level.tmap.cellsize + 1)
			}
		}
		if coll {
			canjump = true
		}
	}

	ent.p.y += my * tophat.delta

	coll := level.tmap.getcoll(ent, &cx, &cy, &tx, &ty)
	if coll {
		my = 0

		if cy == round(ent.p.y) {
			my = gscale*4
			ent.p.y += gscale * tophat.delta * 80 // this is really hacky, but it does the job
		}

		ctx := round((ent.p.x - level.tmap.x) / level.tmap.cellsize)
		cty := round((ent.p.y - level.tmap.y) / level.tmap.cellsize)
		if cy >= round(ent.p.y) + ent.p.h && cty < ty {
			abscy := (cy - level.tmap.y)
			ent.p.y = abscy - abscy%level.tmap.cellsize + level.tmap.y - ent.p.h
			canjump = true
		}
	}

	if canjump && input.isjustpressed(input.KEY_SPACE) {
		my = -0.003 * tophat.delta
		ent.p.y -= 1
		canjump = false
	}

	if my < maxy {
		my += gscale
	}


	ent.draw(global.cam)
}
