
import (
	"th.um"
	"ent.um"
	"rect.um"
	"image.um"
	"signal.um"

	"../game.um"
	"../../logger.um"
	"../../global.um"
)

const (
	speed = 0.01
)

var (
	img: image.Image = image.Image{}
	trans: th.Transform = th.Transform{ s: th.Vf2{1, 1} }
)

type Enemy* = struct {
	e: ^ent.Ent
	pos: th.fu
	hp: int	 
}

fn (enm: ^Enemy) init(pos: th.Vf2) {
	enm.e = new(ent.Ent)
	enm.e^ = ent.mk(img, trans)
	enm.e.c = th.red
	enm.e.r = rect.mk(0, 0, global.tileSize, global.tileSize)
	enm.e.t.p = pos

	enm.hp = 1000
}

fn (enm: ^Enemy) reset() {
	enm.hp = 10
}

fn (enm: ^Enemy) handle() {
	if trunc(enm.pos) + 1 >= len(game.env.path) {
		enm.pos = 0
		signal.emit("path_finish", null)
	}

	b := game.env.path[trunc(enm.pos)]
	e := game.env.path[trunc(enm.pos) + 1]
	enm.e.t.p = th.Vf2{
		b.x + (e.x-b.x) * (enm.pos - trunc(enm.pos)),
		b.y + (e.y-b.y) * (enm.pos - trunc(enm.pos))}

	enm.pos += speed * th.delta / b.distanceTo(e)
}

fn (enm: ^Enemy) draw() {
	enm.e.draw(global.cam)
}

fn (enm: ^Enemy) getEnt(): ^ent.Ent {
	return enm.e
}

fn (enm: ^Enemy) damage(amount: int) {
	enm.hp -= amount
}

fn (enm: ^Enemy) alive(): bool {
	return enm.hp > 0
}
